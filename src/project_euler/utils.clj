(ns project-euler.utils)

(defn square
  [x]
  (* x x))

(defn print-value
  "Prints x and the returns it. Handy to see when lazy values are realized."
  [x]
  (println x)
  x)

(defn fibonnacci
  "Returns an infinite seq of terms in the Fibonnacci sequence."
  []
  (->> (iterate (fn [[a b]] [b (+ a b)]) [1 2])
    (map first)))

(defn divisible?
  "Returns whether or not num is evenly divisible by div."
  [num div]
  (zero? (rem num div)))

(declare primes)

(defn prime?
  "Returns whether or not x is a prime number. Optionally takes an infinite seq
   of primes - used for performance reasons when we don't want to re-create the
   primes seq again and again."
  ([x]
    (cond
      (< x 2) false
      (= x 2) true
      (even? x) false
      :else (not (some #(divisible? x %) (->> x
                                           Math/sqrt
                                           Math/ceil
                                           inc
                                           (range 2)))))))

(defn primes
  "Returns an infinite seq of all primes."
  []
  (cons 2N
    (cons 3N
      (cons 5N
            (->> (iterate (fn [[n [a & r]]]
                            [(+ n a) r])
                          [7N (cycle [2 2 2 4])])
              (map first) 
              (filter prime?))))))


(defn increment-incrementor
  "Used to create sequences where each element in the sequence is dependent
   not on any previous, but on an incrementor which keeps getting updated
   between updates. For example, the triangle numbers
   1, 3, 6, 10, 15, ...
   start at 1 with an incrementor of 2 - this incrementor is then added by 1
   at each step.
   Start signifies the first element, increment-start the initial increment, and
   increment-fn a function of one argument - the previous increment value - returning
   the next increment value."
  [start increment-start increment-fn]
  (map first
       (iterate (fn [[x incr]]
                  [(+ x incr)
                   (increment-fn incr)]) [start increment-start])))

(defn triangulars
  "Returns an infinite seq of the triangular numbers, generated by the formula
  Pn = n(n+1)/2"
  []
  (increment-incrementor 1 2 (partial + 1)))

(defn pentagonals
  "Returns an infinite seq of the pentagonal numbers, generated by the formula
  Pn = n(3n-1)/2"
  []
  (increment-incrementor 1 4 (partial + 3)))

(defn hexagonals
  "Returns an infinite seq of the hexagonal numbers, generated by the formula
  Pn = n(2n-1)"
  []
  (increment-incrementor 1 5 (partial + 4)))


(defn in-non-decreasing-coll?
  "Returns whether or not x is in coll, where coll is a (possibly infinte) seq
   that is non-decreasing."
  [x coll]
  (->> coll
    (drop-while #(< % x))
    first
    (= x)))


(defn quadratic-roots
  "Returns the root(s) of x in the equation
   x^2 + kx + p = 0
   Does not currently support imaginary numbers."
  [k p]
  (let [sqrt (-> (* k k)
               (/ 4)
               (- p)
               Math/sqrt)
        -kdiv2 (- (/ k 2))]
    (into #{} [(+ -kdiv2 sqrt) (- -kdiv2 sqrt)])))

(defn int?
  "Takes a float/double and checks whether or not it's an integer. In addition,
   it will check for cases were float imprecision may have caused a value which
   should be an integer to have some small fractional part."
  [x]
  (cond
    (== x (int x)) true
    (= (Math/floor x) (Math/ceil (- x 0.00000001))) true
    (= (Math/ceil x) (Math/floor (+ x 0.00000001))) true
    :else false))

(defn contains-positive-integers?
  [coll]
  (->> coll
    (filter pos?)
    (some int?)
    true?))

(defn triangular?
  [x]
  (->> (quadratic-roots 1 (- (* 2 x)))
    contains-positive-integers?))

(defn pentagonal?
  [x]
  (->> (quadratic-roots (- (/ 1 3)) (- (/ (* 2 x) 3)))
    contains-positive-integers?))

(defn hexagonal?
  [x]
  (->> (quadratic-roots (- (/ 1 2)) (- (/ 1 2)))
    contains-positive-integers?)) 



(defn reverse-number
  [x]
  (->> x
    str
    reverse
    (drop-while (partial = \0))
    (apply str)
    read-string))

(defn palindrome?
  "Returns whether or not x is a palindromic number. For example, 121 is
   palindromic, whereas 122 is not." 
  [x]
  (= x (reverse-number x)))

(defn !
  [x]
  (if (zero? x) 1
    (apply * (map bigint (range 1 (inc x))))))

(defn r-from-coll
  "Returns a seq of all combinations of choosing r items from coll"
  [r coll]
  (let [f 
        (fn f [r coll subcoll]
          (if
            (= r (count subcoll)) subcoll
            (apply concat
                   (map-indexed
                     (fn [i c]
                       (f r (drop (inc i) coll) (conj subcoll c)))
                     coll))))]
    (partition r (f r coll []))))

(defn count-r-from-n
  "Returns the number of combinations of taking r items from a set of n."
  [r n]
  (/ (! n)
     (* (! r) (! (- n r)))))

(defn remove-nth
  "Returns coll with the nth entry removed."
  [n coll]
  (concat (take n coll) (drop (inc n) coll)))

(defn permutations
  "Returns a seq of all permutations of coll."
  [coll]
  (let [p (fn p [coll subcoll]
            (if (empty? coll)
              subcoll
              (apply concat (map-indexed
                              (fn [i v]
                                (p (remove-nth i coll) (conj subcoll v)))
                              coll))))]
    (partition (count coll) (p coll []))))


(defn digits
  "Returns a seq of the digits in x, which may be an int, long, or string."
  [x]
  (let [s (str x)]
    (map (comp #(Long/parseLong %) str) s)))

(defn pandigital?
  [x]
  (let [str-x (str x)]
    (if (> (count str-x) 9) false
      (let [sorted-x (apply str (sort str-x))
            expected (apply str (range 1 (inc (count sorted-x))))]
        (= sorted-x expected)))))


(defn odd-composites
  "Returns an infinite seq of all odd composites."
  []
  (->> (range)
    (drop 9)
    (take-nth 2)
    (remove prime?)))

(defn sum-of-prime-and-twice-a-square?
  "Returns whether or not x is the sum of a prime number and twice the square of
   some number."
  [x]
  (->> (range 1 x)
    (map square)
    (map (partial * 2))
    (filter (fn [v] (prime? (- x v))))
    first
    nil?
    not))
