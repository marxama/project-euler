(ns project-euler.utils)

(defn fibonnacci
  "Returns an infinite seq of terms in the Fibonnacci sequence."
  []
  (->> (iterate (fn [[a b]] [b (+ a b)]) [1 2])
    (map first)))

(defn divisible?
  "Returns whether or not num is evenly divisible by div."
  [num div]
  (zero? (rem num div)))

(declare primes)

(defn prime?
  [x]
  (cond 
    (< x 2) false
    (= x 2) true
    :else (not (some #(divisible? x %) (->> x
                                         Math/sqrt
                                         Math/ceil
                                         inc
                                         (range 2))))))

(defn primes
  "Returns an infinite seq of all primes."
  []
  (cons 2N
    (cons 3N
      (cons 5N 
            (->> (iterate (fn [[n [a & r]]]
                            [(+ n a) r]) 
                          [7N (cycle [2 2 2 4])])
              (map first) 
              (filter prime?))))))


(defn pentagonals
  "Returns an infinite seq of the pentagonal numbers, generated by the formula
  Pn = n(3n-1)/2"
  []
  (->> (iterate (fn [[_ [n & r]]]
                  [(-> n 
                     (* 3) 
                     (- 1)
                     (* n)
                     (/ 2))
                   r]) [1 (drop 2 (range))])
    (map first)))


(defn reverse-number
  [x]
  (->> x
    str
    reverse
    (drop-while (partial = \0))
    (apply str)
    read-string))

(defn palindrome?
  "Returns whether or not x is a palindromic number. For example, 121 is
   palindromic, whereas 122 is not." 
  [x]
  (= x (reverse-number x)))

(defn !
  [x]
  (if (zero? x) 1
    (apply * (map bigint (range 1 (inc x))))))

(defn r-from-coll
  "Returns a seq of all combinations of choosing r items from coll"
  [r coll]
  (let [f 
        (fn f [r coll subcoll]
          (if 
            (= r (count subcoll)) subcoll
            (apply concat
                   (map-indexed 
                     (fn [i c]
                       (f r (drop (inc i) coll) (conj subcoll c))) 
                     coll))))]
    (partition r (f r coll []))))

(defn count-r-from-n
  "Returns the number of combinations of taking r items from a set of n."
  [r n]
  (/ (! n)
     (* (! r) (! (- n r)))))

(defn digits
  "Returns a seq of the digits in x, which may be an int, long, or string."
  [x]
  (let [s (str x)]
    (map (comp #(Long/parseLong %) str) s)))

(defn pandigital?
  [x]
  (let [str-x (str x)]
    (if (> (count str-x) 9) false
      (let [sorted-x (apply str (sort str-x))
            expected (apply str (range 1 (inc (count sorted-x))))]
        (= sorted-x expected)))))
