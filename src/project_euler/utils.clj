(ns project-euler.utils)

(defn square
  [x]
  (* x x))

(defn print-value
  "Prints x and the returns it. Handy to see when lazy values are realized."
  [x]
  (println x)
  x)

(defn fibonnacci
  "Returns an infinite seq of terms in the Fibonnacci sequence."
  []
  (->> (iterate (fn [[a b]] [b (+ a b)]) [1 2])
    (map first)))

(defn divisible?
  "Returns whether or not num is evenly divisible by div."
  [num div]
  (zero? (rem num div)))

(declare primes)

(defn prime?
  "Returns whether or not x is a prime number. Optionally takes an infinite seq
   of primes - used for performance reasons when we don't want to re-create the
   primes seq again and again."
  ([x]
    (cond
      (< x 2) false
      (= x 2) true
      (even? x) false
      :else (not (some #(divisible? x %) (->> x
                                           Math/sqrt
                                           Math/ceil
                                           inc
                                           (range 2)))))))

(defn primes
  "Returns an infinite seq of all primes."
  []
  (cons 2N
    (cons 3N
      (cons 5N
            (->> (iterate (fn [[n [a & r]]]
                            [(+ n a) r])
                          [7N (cycle [2 2 2 4])])
              (map first) 
              (filter prime?))))))


(defn increment-incrementor
  "Used to create sequences where each element in the sequence is dependent
   not on any previous, but on an incrementor which keeps getting updated
   between updates. For example, the triangle numbers
   1, 3, 6, 10, 15, ...
   start at 1 with an incrementor of 2 - this incrementor is then added by 1
   at each step.
   Start signifies the first element, increment-start the initial increment, and
   increment-fn a function of one argument - the previous increment value - returning
   the next increment value."
  [start increment-start increment-fn]
  (map first
       (iterate (fn [[x incr]]
                  [(+ x incr)
                   (increment-fn incr)]) [start increment-start])))

(defn triangulars
  "Returns an infinite seq of the triangular numbers, generated by the formula
  Pn = n(n+1)/2"
  []
  (increment-incrementor 1 2 (partial + 1)))

(defn pentagonals
  "Returns an infinite seq of the pentagonal numbers, generated by the formula
  Pn = n(3n-1)/2"
  []
  (increment-incrementor 1 4 (partial + 3)))

(defn hexagonals
  "Returns an infinite seq of the hexagonal numbers, generated by the formula
  Pn = n(2n-1)"
  []
  (increment-incrementor 1 5 (partial + 4)))


(defn in-non-decreasing-coll?
  "Returns whether or not x is in coll, where coll is a (possibly infinte) seq
   that is non-decreasing."
  [x coll]
  (->> coll
    (drop-while #(< % x))
    first
    (= x)))


(defn quadratic-roots
  "Returns the root(s) of x in the equation
   x^2 + kx + p = 0
   Does not currently support imaginary numbers."
  [k p]
  (let [sqrt (-> (* k k)
               (/ 4)
               (- p)
               Math/sqrt)
        -kdiv2 (- (/ k 2))]
    (into #{} [(+ -kdiv2 sqrt) (- -kdiv2 sqrt)])))

(defn int?
  "Takes a float/double and checks whether or not it's an integer. In addition,
   it will check for cases were float imprecision may have caused a value which
   should be an integer to have some small fractional part."
  [x]
  (cond
    (== x (int x)) true
    (= (Math/floor x) (Math/ceil (- x 0.00000001))) true
    (= (Math/ceil x) (Math/floor (+ x 0.00000001))) true
    :else false))

(defn contains-positive-integers?
  [coll]
  (->> coll
    (filter pos?)
    (some int?)
    true?))

(defn triangular?
  [x]
  (->> (quadratic-roots 1 (- (* 2 x)))
    contains-positive-integers?))

(defn pentagonal?
  [x]
  (->> (quadratic-roots (- (/ 1 3)) (- (/ (* 2 x) 3)))
    contains-positive-integers?))

(defn hexagonal?
  [x]
  (->> (quadratic-roots (- (/ 1 2)) (- (/ 1 2)))
    contains-positive-integers?)) 



(defn reverse-number
  [x]
  (->> x
    str
    reverse
    (drop-while (partial = \0))
    (apply str)
    read-string))

(defn palindrome?
  "Returns whether or not x is a palindromic number. For example, 121 is
   palindromic, whereas 122 is not." 
  [x]
  (= x (reverse-number x)))

(defn !
  [x]
  (if (zero? x) 1
    (apply * (map bigint (range 1 (inc x))))))

(defn r-from-coll
  "Returns a seq of all combinations of choosing r items from coll"
  [r coll]
  (let [f 
        (fn f [r coll subcoll]
          (if
            (= r (count subcoll)) subcoll
            (apply concat
                   (map-indexed
                     (fn [i c]
                       (f r (drop (inc i) coll) (conj subcoll c)))
                     coll))))]
    (partition r (f r coll []))))

(defn count-r-from-n
  "Returns the number of combinations of taking r items from a set of n."
  [r n]
  (/ (! n)
     (* (! r) (! (- n r)))))

(defn remove-nth
  "Returns coll with the nth entry removed."
  [n coll]
  (concat (take n coll) (drop (inc n) coll)))

(defn permutations
  "Returns a seq of all permutations of coll."
  [coll]
  (let [p (fn p [coll subcoll]
            (if (empty? coll)
              subcoll
              (apply concat (map-indexed
                              (fn [i v]
                                (p (remove-nth i coll) (conj subcoll v)))
                              coll))))]
    (partition (count coll) (p coll []))))


(defn digits
  "Returns a seq of the digits in x, which may be an int, long, or string."
  [x]
  (let [s (str x)]
    (map (comp #(Long/parseLong %) str) s)))

(defn pandigital?
  [x]
  (let [str-x (str x)]
    (if (> (count str-x) 9) false
      (let [sorted-x (apply str (sort str-x))
            expected (apply str (range 1 (inc (count sorted-x))))]
        (= sorted-x expected)))))


(defn odd-composites
  "Returns an infinite seq of all odd composites."
  []
  (->> (range)
    (drop 9)
    (take-nth 2)
    (remove prime?)))

(defn sum-of-prime-and-twice-a-square?
  "Returns whether or not x is the sum of a prime number and twice the square of
   some number."
  [x]
  (->> (range 1 x)
    (map square)
    (map (partial * 2))
    (filter (fn [v] (prime? (- x v))))
    first
    nil?
    not))




(defn parse-poker-card
  "Takes a string of two characters - a value (2-9, T, J, Q, K, A) and a
   suit (H, D, S, C), and returns a map of an integer :value (where T, J, Q, K 
   and A and are translated to 10, 11, 12, 13 and 14, respectively) and a :suit 
   of :hearts, :diamonds, :spades, or :clubs."
  [s]
  (let [[value-char suit-char] (.toUpperCase s)
        value-str (str value-char) 
        value (cond
                (re-find #"\d" value-str) (Integer/parseInt value-str)
                :else (case value-char
                        \T 10
                        \J 11
                        \Q 12
                        \K 13
                        \A 14))
        suit (case suit-char
               \H :hearts
               \D :diamonds
               \S :spades
               \C :clubs)]
    {:value value :suit suit}))


(defn poker-hand-value
  "Takes a collection of five cards (each being a map with a :suit and a :value),
   and returns the value of the cards as defined in the game of Poker. A hand
   can be valued at several depths, and as such, a seq of values are returned,
   where the first has dominance over the second, and so on.

   For example, a pair would get a first value of 1, a two-pair would get a first
   value of 2, and so on. The pair would get another value following the first value,
   stating the value of the cards we have the pair in. Following this, we fill up
   with the remaining three values, in order from highest to lowest. This allows us
   to see that a pair in queens with a 10, 8 and 5 is worth more than a pair in queens
   with a 10, 8, and 4."
  [coll]
  (let [values (map :value coll)
        sorted-freqs (->> (frequencies values)
                       ; here, we sort first on count, then on value
                       (sort (comparator (fn [[k1 v1] [k2 v2]]
                                           (cond 
                                             (= v1 v2) (< k1 k2)
                                             :else (< v1 v2)))))
                       reverse)
        counts-in-order (map val sorted-freqs)
        values-in-order-of-freq-then-value (map key sorted-freqs)
        flush? (apply = (map :suit coll))
        straight? (or
                    (apply = (map - (sort values) (range)))
                    (apply = (map - (sort
                                      (replace {14 1} values))
                                  (range))))
        highest-straight-value #(if (and (= 14 (apply max values))       ; a somewhat ugly way of checking the special
                                         (empty? (filter #{13} values))) ; case where Ace is used as 1 in a straight
                                  5
                                  (apply max values))]
    (cond
      ;; Royal flush
      (and flush?
           (= [10 11 12 13 14] (sort values)))
      [9]
      
      ;; Straight flush
      (and flush? straight?)
      (conj [8] (highest-straight-value))
      
      ;; Four of a kind
      (= 4 (first counts-in-order))
      (cons 7 values-in-order-of-freq-then-value)
      
      ;; Full house
      (and (= 3 (first counts-in-order))
           (= 2 (second counts-in-order)))
      (cons 6 values-in-order-of-freq-then-value)
      
      ;; Flush
      flush?
      (cons 5 values-in-order-of-freq-then-value)
      
      ;; Straight
      straight?
      (conj [4] (highest-straight-value))
      
      ;; Three of a kind
      (= 3 (first counts-in-order))
      (cons 3 values-in-order-of-freq-then-value)
      
      ;; Two pairs
      (= 2 (first counts-in-order) (second counts-in-order))
      (cons 2 values-in-order-of-freq-then-value)
      
      ;; One pair
      (= 2 (first counts-in-order))
      (cons 1 values-in-order-of-freq-then-value)
      
      :else
      (cons 0 values-in-order-of-freq-then-value))))


(defn compare-poker-hands
  "Compares two poker hands, represented by collections of maps of :suit and :value.
   Uses standard Comparable semantics - if hand-1 < hand-2 we return a negative int,
   if hand-1 > hand-2 we return a positive value, and if hand-1 = hand-2, we return 0."
  [hand-1 hand-2]
  (let [result (->> 
                 (map - (poker-hand-value hand-1) (poker-hand-value hand-2))
                 (remove zero?)
                 first)]
    (if (nil? result) 
      0 
      result)))
