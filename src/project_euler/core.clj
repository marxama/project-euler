(ns project-euler.core
  (:require [project-euler.utils :as utils]))


(defn problem-1
"If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

Find the sum of all the multiples of 3 or 5 below 1000."
  []
  (->> (range 1000)
    (filter #(or (utils/divisible? % 3)
                 (utils/divisible? % 5)))
    (apply +)))


(defn problem-2
"Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms."
  []
  (->> (utils/fibonnacci)
    (filter even?)
    (take-while #(< % 4000000))
    (apply +)))


(defn problem-3
"The prime factors of 13195 are 5, 7, 13 and 29.

What is the largest prime factor of the number 600851475143 ?"
  []
  (let [num 600851475143
        possible-primes (->> (utils/primes)
                          (take-while #(< % (-> num
                                              Math/sqrt
                                              Math/ceil
                                              long))))]
    (->> possible-primes
      reverse
      (filter #(zero? (rem num %)))
      first)))


(defn problem-4
"A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 99.

Find the largest palindrome made from the product of two 3-digit numbers."
  []
  (let [products (for [x (reverse (range 100 1000))
                       y (reverse (range x 1000))]
                   (* x y))
        palindromes (filter utils/palindrome? products)]
    (apply max palindromes)))


(defn problem-5
"2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.

What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?

SOLUTION: Being smart about it, it's very straight forward. All primes from 2 to 20 will need to be part of
the product. In addition, some of the primes will need to be applied multiple times, since divisibility by 2
does not imply divisibility by 4 - however, divisibility by 2 * 2 and 3 does imply divisibility by both 4, 6
12, for example."
  []
  (* 2 2 2 2 3 3 5 7 11 13 17 19)
  #_(->> (range)
    (drop 1)
    (filter #(every? (partial utils/divisible? %) (range 1 21)))
    first))


(defn problem-6
"Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.

IMPROVEMENTS: I just know there's a good formula for this..."
  []
  (let [sum-of-squares (->> (range 1 101)
                         (map #(* % %))
                         (apply +))
        square-of-sums (->> (range 1 101)
                         (apply +)
                         (#(* % %)))]
    (- square-of-sums sum-of-squares)))


(defn problem-7
"By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.

What is the 10 001st prime number?"
  []
  (nth (utils/primes) 10000))


(def problem-8-input
  "73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450")

(defn problem-8
"Find the greatest product of five consecutive digits in the 1000-digit number."
  []
  (let [digits (->> problem-8-input
                 (remove #{\newline})
                 (apply str)
                 utils/digits)
        products (->> digits
                   (partition 5 1)
                   (remove #(some (partial = 0) %)) ;let's count sequences with 0 out
                   (map (partial apply *)))]
    (apply max products)))


(defn problem-9
"There exists exactly one Pythagorean triplet for which a + b + c = 1000.
Find the product abc."
  []
  (let [square #(* % %)]
    (->> (for [a (range 1 1000)
               b (range (inc a) 1000)]
           (let [c (- 1000 a b)]
             (if (= (+ (square a) (square b)) (square c))
               (* a b c)
               nil)))
      (remove nil?)
      first)))


(defn problem-10
"The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.

Find the sum of all the primes below two million."
  []
  (->> (utils/primes)
    (take-while #(< % 2000000))
    (apply +)))


(defn problem-29
  []
  (let [a (map bigint (range 2 101))
        b (map bigint (range 2 101))]
    (->> (for [a a
               b b]
           (apply * (repeat b a)))
      distinct
      count)))


(defn problem-31
"In England the currency is made up of pound, £, and pence, p, and there are eight coins in general circulation:

1p, 2p, 5p, 10p, 20p, 50p, £1 (100p) and £2 (200p).
It is possible to make £2 in the following way:

1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p
How many different ways can £2 be made using any number of coins?"
  []
  (let [target 200
        coins [200 100 50 20 10 5 2 1]
        values-for (fn [coin sum]
                     (map #(* coin %) (range 0 (inc (/ (- target sum) coin)))))]
    (->> coins
      sort reverse
      (reduce (fn [sums coin]
                (for [sum sums
                      coin-sum (values-for coin sum)]
                  (+ sum coin-sum))) [0])
      (filter #(= target %))
      count)))


(defn problem-32
"We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once; for example, the 5-digit number, 15234, is 1 through 5 pandigital.

The product 7254 is unusual, as the identity, 39  186 = 7254, containing multiplicand, multiplier, and product is 1 through 9 pandigital.

Find the sum of all products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital.

HINT: Some products can be obtained in more than one way so be sure to only include it once in your sum.

SOLUTION: An optimization below is that the number of digits in the product
is either the total number of digits in the multiplicand and the multiplier,
or one less. This means that we are only looking for cases where the total
number of digits in the multiplicand and the multiplier is 5. We are also
obviously utilizing the fact that multiplication is commutative, which gives us
that we only need to check multiplicands and multipliers with 1x4 or 2x3 digits."
  []
  (let [products (for [multiplicand (range 1 99)
                       multiplier (case (count (str multiplicand))
                                    1 (range 1234 9877)
                                    2 (range 123 988))]
                   (let [product (* multiplicand multiplier)]
                     (if (utils/pandigital? (str multiplicand multiplier product))
                       product
                       nil)))]
    (->> products
      (remove nil?)
      (into #{})
      (apply +))))


(defn problem-33
"The fraction 49/98 is a curious fraction, as an inexperienced mathematician in attempting to simplify it may incorrectly believe that 49/98 = 4/8, which is correct, is obtained by cancelling the 9s.

We shall consider fractions like, 30/50 = 3/5, to be trivial examples.

There are exactly four non-trivial examples of this type of fraction, less than one in value, and containing two digits in the numerator and denominator.

If the product of these four fractions is given in its lowest common terms, find the value of the denominator."
  []
  (->> (for [numerator (range 1 10)
             denominator (range numerator 10)
             common-digit (range 1 10)]
         (let [n1 (+ numerator (* 10 common-digit))
               n2 (+ (* 10 numerator) common-digit)
               d1 (+ denominator (* 10 common-digit))
               d2 (+ (* 10 denominator) common-digit)
               fractions [(/ n1 d1) (/ n2 d1) (/ n1 d2) (/ n2 d2)]]
           (->> fractions
             (filter #(< % 1))
             (filter (partial = (/ numerator denominator))))))
    (apply concat)
    (apply *)
    (denominator)))


(defn problem-37
"The number 3797 has an interesting property. Being prime itself, it is possible to continuously remove digits from left to right, and remain prime at each stage: 3797, 797, 97, and 7. Similarly we can work from right to left: 3797, 379, 37, and 3.

Find the sum of the only eleven primes that are both truncatable from left to right and right to left.

NOTE: 2, 3, 5, and 7 are not considered to be truncatable primes.

IMPROVEMENTS: Do not convert between numbers and strings."
  []
  (let [truncations (fn [x rest-or-butlast]
                      (->> x
                        str
                        seq
                        (iterate #(rest-or-butlast %))
                        (take-while (complement empty?))
                        (map (partial apply str))
                        (map #(Long/parseLong %)))) 
        all-truncations (fn [x]
                          (concat (truncations x rest)
                                  (truncations x butlast)))
        truncatable? (fn [x]
                       (every? utils/prime? (all-truncations x)))
        truncatable-primes (->> (utils/primes)
                             (drop 4)
                             (filter truncatable?)
                             (take 11))]
    (apply + truncatable-primes)))


(defn problem-39
"If p is the perimeter of a right angle triangle with integral length sides, {a,b,c}, there are exactly three solutions for p = 120.

{20,48,52}, {24,45,51}, {30,40,50}

For which value of p  1000, is the number of solutions maximised?

SOLUTION: Let a, b, c be the sides of each triangle, such that a <= b < c.
The largest value for a will be approximately 293 (when a = b, and 
a + b + c = 1000). Knowing a, we know that b <= (1000 - a) / 2 - but of course,
we are only looking for integers, so keep that in mind.
Knowing a and b, we can calculate c (and, in particular, filter on whether 
or not it's an integer).
c will not be more than 499. In order to determine whether or not sqrt(a^2 + b^2)
is an integer, and in order to quickly get the value of c if it is, we keep a map
from the squares to their corresponding square root."
  []
  (let [squares (zipmap (map utils/square (range 1 500))
                        (range 1 500))
        perimeters (for [a (range 1 294)
                            b (range 1 (Math/ceil (/ (- 1000 a)
                                                     2)))
                            :let [c (get squares (+ (utils/square a)
                                                    (utils/square b)))]
                            :when (and (not (nil? c))
                                       (<= (+ a b c) 1000))]
                        (+ a b c))]
    (->> (frequencies perimeters)
      (sort-by val) ; sort by count
      last ; choose the (perimeter, count) pair with the highest count
      first)))


(defn problem-40
"An irrational decimal fraction is created by concatenating the positive integers:

0.123456789101112131415161718192021...

It can be seen that the 12th digit of the fractional part is 1.

If dn represents the nth digit of the fractional part, find the value of the following expression.

d1 * d10 * d100 * d1000 * d10000 * d100000 * d1000000"
  []
  (let [digits (->> (range)
                 (drop 1)
                 (mapcat str)
                 (map (comp #(Integer/parseInt %) str)))]
    (apply *
           (map (partial nth digits) [0 9 99 999 9999 99999 999999]))))


(defn problem-44
"Pentagonal numbers are generated by the formula, Pn=n(3n-1)/2. The first ten pentagonal numbers are:

1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70  22 = 48, is not pentagonal.

Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference is pentagonal and D = |Pk  Pj| is minimised; what is the value of D?

COMMENT: This one needs serious improvements."
  []
  (let [pentagonals (take 5000 (utils/pentagonals))
        pentagonal-pairs (for [a pentagonals
                               b pentagonals
                               :when (< a b)]
                           [a b])
        pentagonal? (into #{} pentagonals)]
    (->> pentagonal-pairs
      (reduce (fn [result [a b]]
                (if (and (pentagonal? (- b a))
                         (pentagonal? (+ a b)))
                  (conj result (- b a))
                  result)) [])
      sort
      first)))


(defn problem-45
"Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:

Triangle	 	Tn=n(n+1)/2	 	1, 3, 6, 10, 15, ...
Pentagonal	Pn=n(3n1)/2	 	1, 5, 12, 22, 35, ...
Hexagonal	 	Hn=n(2n1)	 	1, 6, 15, 28, 45, ...
It can be verified that T285 = P165 = H143 = 40755.

Find the next triangle number that is also pentagonal and hexagonal.

SOLUTION: Pretty straight-forward. We check each hexagonal number after the
146:th one whether it's pentagonal or not. No need to check if it's triangular;
hexagonal numbers are always triangular."
  []
  (->> (utils/hexagonals)
    (drop 146)
    (drop-while (complement utils/pentagonal?))
    first)) 


(defn problem-46
"It was proposed by Christian Goldbach that every odd composite number can be written as the sum of a prime and twice a square.

9 = 7 + 2*1^2
15 = 7 + 2*2^2
21 = 3 + 2*3^2
25 = 7 + 2*3^2
27 = 19 + 2*2^2
33 = 31 + 2*1^2

It turns out that the conjecture was false.

What is the smallest odd composite that cannot be written as the sum of a prime and twice a square?"
  []
  (->> (utils/odd-composites)
    (remove utils/sum-of-prime-and-twice-a-square?)
    first))


(defn problem-49
"The arithmetic sequence, 1487, 4817, 8147, in which each of the terms increases by 3330, is unusual in two ways: (i) each of the three terms are prime, and, (ii) each of the 4-digit numbers are permutations of one another.

There are no arithmetic sequences made up of three 1-, 2-, or 3-digit primes, exhibiting this property, but there is one other 4-digit increasing sequence.

What 12-digit number do you form by concatenating the three terms in this sequence?"
  []
  (->> (utils/primes)
    (drop-while #(< % 1000))
    (take-while #(< % 3340))
    (remove #{1487})
    (map #(do [% (+ % 3330) (+ % 6660)]))
    (filter (partial every? utils/prime?))
    (filter (fn [coll] (apply = (map (comp sort str) coll))))
    (map (partial apply str))))


(defn problem-52
"It can be seen that the number, 125874, and its double, 251748, contain exactly the same digits, but in a different order.

Find the smallest positive integer, x, such that 2x, 3x, 4x, 5x, and 6x, contain the same digits."
  []
  (letfn [(have-same-digits 
            [& xs]
            (->>
              (map (comp sort seq str) xs)
              (apply =)))
          (test-digit
            [x]
            (apply have-same-digits (map * (repeat x) (range 1 7))))]
         (->> (drop 1 (range))
           (drop-while (complement test-digit))
           first)))


(defn problem-53
  []
  (let [counts (apply concat
                      ; Remember that nCr = nC(n-r)
                      (for [n (range 1 101)
                            r (range 1 (-> (/ n 2)
                                         int
                                         inc))]
                        (let [count (utils/count-r-from-n r n)]
                          (if (= r (/ n 2))
                            [count]
                            [count count]))))]
    (->> counts
      (filter #(> % 1000000))
      count)))


(defn problem-54-parse-input
  "Returns a seq of maps, each containing :player1 and :player2, each in
   turn holding a seq representing a poker hand." 
  []
  (let [lines (-> (System/getProperty "user.dir")
                (str  "\\data\\problem54.txt")
                slurp
                (.split "\n"))
        games (->> lines
                (map #(.split % " "))
                (map (fn [game]
                       {:player1 (map utils/parse-poker-card (take 5 game))
                        :player2 (map utils/parse-poker-card (take 5 (drop 5 game)))})))]
    games))


(defn problem-54
"In the card game poker, a hand consists of five cards and are ranked, from lowest to highest, in the following way:

High Card: Highest value card.
One Pair: Two cards of the same value.
Two Pairs: Two different pairs.
Three of a Kind: Three cards of the same value.
Straight: All cards are consecutive values.
Flush: All cards of the same suit.
Full House: Three of a kind and a pair.
Four of a Kind: Four cards of the same value.
Straight Flush: All cards are consecutive values of same suit.
Royal Flush: Ten, Jack, Queen, King, Ace, in same suit.

The cards are valued in the order:
2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King, Ace.

If two players have the same ranked hands then the rank made up of the highest value wins; for example, a pair of eights beats a pair of fives (see example 1 below). But if two ranks tie, for example, both players have a pair of queens, then highest cards in each hand are compared (see example 4 below); if the highest cards tie then the next highest cards are compared, and so on.

The file, poker.txt, contains one-thousand random hands dealt to two players. Each line of the file contains ten cards (separated by a single space): the first five are Player 1's cards and the last five are Player 2's cards. You can assume that all hands are valid (no invalid characters or repeated cards), each player's hand is in no specific order, and in each hand there is a clear winner.

How many hands does Player 1 win?"
  []
  (->> (problem-54-parse-input)
    (map #(utils/compare-poker-hands (:player1 %) (:player2 %)))
    (filter pos?)
    count))


(defn problem-55
"If we take 47, reverse and add, 47 + 74 = 121, which is palindromic.

Not all numbers produce palindromes so quickly. For example,

349 + 943 = 1292,
1292 + 2921 = 4213
4213 + 3124 = 7337

That is, 349 took three iterations to arrive at a palindrome.

Although no one has proved it yet, it is thought that some numbers, like 196, never produce a palindrome. A number that never forms a palindrome through the reverse and add process is called a Lychrel number. Due to the theoretical nature of these numbers, and for the purpose of this problem, we shall assume that a number is Lychrel until proven otherwise. In addition you are given that for every number below ten-thousand, it will either (i) become a palindrome in less than fifty iterations, or, (ii) no one, with all the computing power that exists, has managed so far to map it to a palindrome. In fact, 10677 is the first number to be shown to require over fifty iterations before producing a palindrome: 4668731596684224866951378664 (53 iterations, 28-digits).

Surprisingly, there are palindromic numbers that are themselves Lychrel numbers; the first example is 4994.

How many Lychrel numbers are there below ten-thousand?"
  []
  (letfn [(lychrel?
            [x]
            (->> (iterate #(+ % (utils/reverse-number %)) x)
              (drop 1)
              (take 49)
              (some utils/palindrome?)
              not))]
         (->> (range 1 10000)
           (map bigint)
           (filter lychrel?)
           count)))

(defn problem-56
"A googol (10^100) is a massive number: one followed by one-hundred zeros; 100^100 is almost unimaginably large: one followed by two-hundred zeros. Despite their size, the sum of the digits in each number is only 1.

Considering natural numbers of the form, ab, where a, b  100, what is the maximum digital sum?"
  []
  (apply max
         (apply concat
                (for [a (range 1 100)]
                  (map (comp (partial apply +) utils/digits)
                       (reductions (fn [acc _] (* acc a)) 1N (range 1 100)))))))


(defn problem-67
"By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.

3
7 4
2 4 6
8 5 9 3

That is, 3 + 7 + 4 + 9 = 23.

Find the maximum total from top to bottom in triangle.txt (right click and 'Save Link/Target As...'), a 15K text file containing a triangle with one-hundred rows.

SOLUTION: Working from the bottom up, we take the maximum of a node's children
and add it to the node, working recursively until we reach the root.
Obviosly, some tree structure would be suitable here, although the current
solution works instantly. To revisit later, try to use some of Clojure's
tree-walking functions."
  []
  (let [lines (-> (System/getProperty "user.dir")
                (str  "\\data\\problem67.txt")
                slurp
                (.split "\n")
                reverse)
        lines (->> lines
                (map #(.split % " "))
                (map (fn [line] (map #(Integer/parseInt %) line))))]
    (loop [[top-line second-line & rest-lines] lines]
      (if (nil? second-line)
        (first top-line)
        (recur (conj rest-lines
                     (map + second-line 
                          (->> (partition 2 1 top-line)
                            (map (partial apply max))))))))))
