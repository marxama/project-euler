(ns project-euler.core
  (:require [project-euler.utils :as utils]))


(defn problem-1
"If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

Find the sum of all the multiples of 3 or 5 below 1000."
  []
  (->> (range 1000)
    (filter #(or (utils/divisable? % 3)
                 (utils/divisable? % 5)))
    (apply +)))


(defn problem-2
"Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms."
  []
  (->> (utils/fibonnacci)
    (filter even?)
    (take-while #(< % 4000000))
    (apply +)))


(defn problem-3
"The prime factors of 13195 are 5, 7, 13 and 29.

What is the largest prime factor of the number 600851475143 ?"
  []
  (let [num 600851475143
        possible-primes (->> (utils/primes)
                          (take-while #(< % (-> num
                                              Math/sqrt
                                              Math/ceil
                                              long))))]
    (->> possible-primes
      reverse
      (filter #(zero? (rem num %)))
      first)))


(defn problem-4
"A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 99.

Find the largest palindrome made from the product of two 3-digit numbers."
  []
  (let [products (for [x (reverse (range 100 1000))
                       y (reverse (range x 1000))]
                   (* x y))
        palindromes (filter utils/palindrome? products)]
    (apply max palindromes)))


(defn problem-5
"2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.

What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?"
  []
  (->> (range)
    (drop 1)
    (filter #(every? (partial utils/divisable? %) (range 1 21)))
    first))


(defn problem-29
  []
  (let [a (map bigint (range 2 101))
        b (map bigint (range 2 101))]
    (->> (for [a a
               b b]
           (apply * (repeat b a)))
      distinct
      count)))


(defn problem-52
"It can be seen that the number, 125874, and its double, 251748, contain exactly the same digits, but in a different order.

Find the smallest positive integer, x, such that 2x, 3x, 4x, 5x, and 6x, contain the same digits."
  []
  (letfn [(have-same-digits 
            [& xs]
            (->>
              (map (comp sort seq str) xs)
              (apply =)))
          (test-digit
            [x]
            (apply have-same-digits (map * (repeat x) (range 1 7))))]
         (->> (drop 1 (range))
           (drop-while (complement test-digit))
           first)))


(defn problem-53
  []
  (let [counts (apply concat
                      ; Remember that nCr = nC(n-r)
                      (for [n (range 1 101)
                            r (range 1 (-> (/ n 2)
                                         int
                                         inc))]
                        (let [count (utils/count-r-from-n r n)]
                          (if (= r (/ n 2))
                            [count]
                            [count count]))))]
    (->> counts
      (filter #(> % 1000000))
      count)))


(defn problem-55
"If we take 47, reverse and add, 47 + 74 = 121, which is palindromic.

Not all numbers produce palindromes so quickly. For example,

349 + 943 = 1292,
1292 + 2921 = 4213
4213 + 3124 = 7337

That is, 349 took three iterations to arrive at a palindrome.

Although no one has proved it yet, it is thought that some numbers, like 196, never produce a palindrome. A number that never forms a palindrome through the reverse and add process is called a Lychrel number. Due to the theoretical nature of these numbers, and for the purpose of this problem, we shall assume that a number is Lychrel until proven otherwise. In addition you are given that for every number below ten-thousand, it will either (i) become a palindrome in less than fifty iterations, or, (ii) no one, with all the computing power that exists, has managed so far to map it to a palindrome. In fact, 10677 is the first number to be shown to require over fifty iterations before producing a palindrome: 4668731596684224866951378664 (53 iterations, 28-digits).

Surprisingly, there are palindromic numbers that are themselves Lychrel numbers; the first example is 4994.

How many Lychrel numbers are there below ten-thousand?"
  []
  (letfn [(lychrel?
            [x]
            (->> (iterate #(+ % (utils/reverse-number %)) x)
              (drop 1)
              (take 49)
              (some utils/palindrome?)
              not))]
         (->> (range 1 10000)
           (map bigint)
           (filter lychrel?)
           count)))
